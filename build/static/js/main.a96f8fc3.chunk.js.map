{"version":3,"sources":["components/Todo.tsx","components/TodoList.tsx","components/TodoForm.tsx","components/TodoFormContainer.tsx","components/ThemeContext.ts","components/ToolBar.tsx","components/Notifier.tsx","Webcam.ts","components/CloudCamera/index.tsx","App.tsx","registerServiceWorker.ts","index.tsx"],"names":["Todo","props","todo","react","className","style","textDecoration","isCompleted","text","onClick","onComplete","index","onRemove","TodoListRenderer","todos","todosRender","length","push","Todo_Todo","key","TodoForm","onSubmit","type","value","onChange","TodoFormContainer","_useState","useState","_useState2","Object","slicedToArray","setValue","e","preventDefault","addTodo","target","themes","light","foreground","background","color","dark","ThemeContext","React","theme","toggleTheme","Toolbar","Notifier","message","offline","Webcam","webcamElement","canvasElement","classCallCheck","this","createClass","width","height","aspectRatio","_setup","asyncToGenerator","regenerator_default","a","mark","_callee2","_this","wrap","_context2","prev","next","abrupt","Promise","resolve","reject","undefined","navigator","mediaDevices","getUserMedia","audio","video","facingMode","then","mediaStream","srcObject","src","window","URL","createObjectURL","addEventListner","_callee","_context","adjustVideoSize","videoWidth","videoHeight","stop","apply","arguments","imageWidth","imageHeight","context","getContext","drawImage","_this2","_this$_drawImage","_drawImage","toBlob","blob","_ref2","quality","_this$_drawImage2","base64","toDataURL","CloudCamera","_React$Component","state","possibleConstructorReturn","getPrototypeOf","call","webcam","captureImage","capturedData","takeBase64Photo","setState","captured","capturedImage","discardImage","uploadImage","console","log","rs","Math","random","toString","substr","localStorage","setItem","concat","alert","uploading","axios","post","file","upload_preset","data","checkUploadStatus","catch","error","findLocalItems","query","i","results","hasOwnProperty","match","getItem","val","status","batchUploads","images","inherits","document","createElement","getElementById","setup","prevProps","imageDisplay","alt","buttons","autoPlay","playsInline","muted","id","App","setTodos","_useState3","_useState4","setTheme","_useState5","_useState6","setOffline","_useState7","_useState8","toggleThemeCount","setToggleThemeCount","useEffect","addEventListener","offlineStatus","onLine","title","Provider","TodoList_TodoListRenderer","newTodos","toConsumableArray","splice","todoText","Notifier_Notifier","components_CloudCamera_CloudCamera","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","ReactDOM","render","react_default","src_App_0","process","href","origin","fetch","response","contentType","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.a96f8fc3.chunk.js","sourcesContent":["import * as React from \"react\";\r\nimport { ITodo } from \"./IApp\";\r\n\r\ninterface ITodoProps {\r\n    index: number;\r\n    todo: ITodo;\r\n    onComplete: (index: number) => void;\r\n    onRemove: (index: number) => void;\r\n}\r\n\r\nexport const Todo = (props: ITodoProps) => {\r\n    const { todo } = props;\r\n    return  (\r\n        <div\r\n          className=\"todo\"\r\n          style={{ textDecoration: todo.isCompleted ? \"line-through\" : \"\" }}\r\n          >\r\n          {todo.text}\r\n    \r\n          <div>\r\n            <button onClick={() => { props.onComplete(props.index) }}>Complete</button>\r\n            <button onClick={() => { props.onRemove(props.index) }}>x</button>\r\n          </div>\r\n        </div>\r\n      );\r\n}","import * as React from \"react\";\r\nimport { ITodo } from \"./IApp\";\r\n\r\nimport { Todo } from \"./Todo\";\r\n\r\ninterface ITodoListRendererProps {\r\n    todos: ITodo[];\r\n    onComplete: (index: number) => void;\r\n    onRemove: (index: number) => void;\r\n}\r\n\r\nexport const TodoListRenderer = (props: ITodoListRendererProps) => {\r\n    const { todos } = props;\r\n    const todosRender: any[] = [];\r\n    for (let index = 0; index < todos.length; index++) {\r\n        todosRender.push(<Todo\r\n            key={index}\r\n            index={index}\r\n            todo={todos[index]}\r\n            onComplete={props.onComplete}\r\n            onRemove={props.onRemove}\r\n        />);\r\n    }\r\n    return (\r\n        <div className=\"todoList\">\r\n            {todosRender}\r\n        </div>\r\n    );\r\n}","import * as React from \"react\";\r\n\r\ninterface ITodoFormProps {\r\n  value: string;\r\n  onChange: (e: any) => void;\r\n  onSubmit: (e: any) => void;\r\n}\r\n\r\nexport function TodoForm(props: ITodoFormProps){\r\n    return (\r\n        <form onSubmit={props.onSubmit}>\r\n          <input className=\"todoInput\"\r\n            type=\"text\"\r\n            value={props.value}\r\n            onChange={props.onChange}\r\n          />\r\n        </form>\r\n      );\r\n}","import * as React from \"react\";\r\nimport { useState } from \"react\";\r\n\r\nimport { TodoForm } from \"../components/TodoForm\";\r\n\r\ninterface ITodoFormContainerProps {\r\n    addTodo: (text: string) => void;\r\n}\r\n\r\nexport function TodoFormContainer(props: ITodoFormContainerProps) {\r\n    const [value, setValue] = useState(\"\");\r\n\r\n    const onChange = (e: any) => {\r\n        setValue(e.target.value);\r\n    };\r\n\r\n    const handleSubmit = (e: Event) => {\r\n        e.preventDefault();\r\n        if (value) {\r\n            props.addTodo(value);\r\n            setValue(\"\");\r\n        }\r\n    }\r\n    return (\r\n        <TodoForm value={value} onSubmit={handleSubmit} onChange={onChange} />\r\n    );\r\n}","import * as React from \"react\";\r\n\r\nexport const themes = {\r\n    light: {\r\n      foreground: '#000000',\r\n      background: '#eeeeee',\r\n      color: '#000000',\r\n    },\r\n    dark: {\r\n      foreground: '#ffffff',\r\n      background: '#222222',\r\n      color: '#ffffff',\r\n    },\r\n  };\r\n\r\n  export const ThemeContext = React.createContext(\r\n    {\r\n        theme: themes.dark,\r\n        toggleTheme: () => {},\r\n      }\r\n  );","import * as React from \"react\";\r\nimport { ThemedButton } from \"./ThemedButton\";\r\n\r\n// An intermediate component that uses the ThemedButton\r\nexport function Toolbar() {\r\n    return (\r\n      <h1 className=\"header\">Task Assistant</h1>\r\n    );\r\n  }","import * as React from \"react\";\r\nimport \"../App.css\";\r\n\r\nexport const Notifier = (props: any) => {\r\n    const message = props.offline ?\r\n        `CloudyCam is offline! Your images will be saved now and then uploaded to your Cloudinary Media Library once your Internet connection is back up.`\r\n        :\r\n        `Take a picture and it will be uploaded to your Cloudinary Media Library.`;\r\n    return (\r\n        <div className=\"notify\">\r\n            <p>\r\n                <em>{message}</em>\r\n            </p>\r\n        </div>\r\n    );\r\n}","export class Webcam {\r\n    private webcamElement: any;\r\n    private canvasElement: any;\r\n    constructor(webcamElement: any, canvasElement: any) {\r\n        this.webcamElement = webcamElement;\r\n        this.canvasElement = canvasElement;\r\n    }\r\n\r\n    public adjustVideoSize(width: number, height: number) {\r\n        const aspectRatio = width/ height;\r\n        if(width >= height) {\r\n           this.webcamElement.width = aspectRatio * this.webcamElement.height;\r\n        } else {\r\n            this.webcamElement.height = this.webcamElement.width / aspectRatio;\r\n        }\r\n    }\r\n\r\n    public async setup() {\r\n        return new Promise((resolve, reject) => {\r\n            if(navigator.mediaDevices.getUserMedia !== undefined) {\r\n                navigator.mediaDevices.getUserMedia({\r\n                    audio: false,\r\n                    video: {\r\n                        facingMode: 'user'\r\n                    }\r\n                })\r\n                .then((mediaStream) => {\r\n                    if(\"srcObject\" in this.webcamElement) {\r\n                        this.webcamElement.srcObject = mediaStream;\r\n                    } else {\r\n                        // for older browsers without the src object\r\n                        this.webcamElement.src = window.URL.createObjectURL(mediaStream);\r\n                    }\r\n                    this.webcamElement.addEventListner(\r\n                        'loadeddata',\r\n                        async () => {\r\n                            this.adjustVideoSize(\r\n                                this.webcamElement.videoWidth,\r\n                                this.webcamElement.videoHeight\r\n                            );\r\n                        },\r\n                        false\r\n                    );\r\n                });\r\n\r\n            } else {\r\n                reject();\r\n            }\r\n        })\r\n    }\r\n\r\n    public _drawImage() {\r\n        const imageWidth = this.webcamElement.videoWidth;\r\n        const imageHeight = this.webcamElement.videoHeight;\r\n\r\n        const context = this.canvasElement.getContext('2d');\r\n        this.canvasElement.width = imageWidth;\r\n        this.canvasElement.height = imageHeight;\r\n\r\n        context.drawImage(this.webcamElement, 0, 0, imageWidth, imageHeight);\r\n        return { imageHeight, imageWidth };\r\n      }\r\n\r\n     public takeBlobPhoto() {\r\n        const { imageWidth, imageHeight } = this._drawImage();\r\n        return new Promise((resolve, reject) => {\r\n            this.canvasElement.toBlob((blob: any) => {\r\n                resolve({ blob, imageHeight, imageWidth });\r\n            });\r\n        });\r\n      }\r\n\r\n      public takeBase64Photo({ type, quality } = { type: 'png', quality: 1 }) {\r\n        const { imageHeight, imageWidth } = this._drawImage();\r\n        const base64 = this.canvasElement.toDataURL('image/' + type, quality);\r\n        return { base64, imageHeight, imageWidth };\r\n      }\r\n}","import * as React from \"react\";\r\nimport { Webcam } from '../../Webcam';\r\nimport './CloudCamera.css';\r\nimport axios from 'axios';\r\n\r\nexport class CloudCamera extends React.Component<any, any> {\r\n    private canvasElement: any;\r\n    private webcam: any;\r\n    public constructor(props: any, state: any) {\r\n        super(props, state);\r\n        this.state = {\r\n            capturedImage: null,\r\n            captured: false,\r\n            uploading: false\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        // initialize the camera\r\n        this.canvasElement = document.createElement('canvas');\r\n        this.webcam = new Webcam(\r\n            document.getElementById('webcam'),\r\n            this.canvasElement\r\n        );\r\n        this.webcam.setup().catch(() => {\r\n            alert('Error getting access to your camera');\r\n        });\r\n    }\r\n\r\n    componentDidUpdate(prevProps: any) {\r\n        if (!this.props.offline && (prevProps.offline === true)) {\r\n            // if its online\r\n            this.batchUploads();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const imageDisplay = this.state.capturedImage ?\r\n            <img src={this.state.capturedImage} alt=\"captured\" width=\"350\" />\r\n            :\r\n            <span />;\r\n\r\n        const buttons = this.state.captured ?\r\n            <div>\r\n                <button className=\"deleteButton\" onClick={this.discardImage} > Delete Photo </button>\r\n                <button className=\"captureButton\" onClick={this.uploadImage} > Upload Photo </button>\r\n            </div> :\r\n            <button className=\"captureButton\" onClick={this.captureImage} > Take Picture </button>\r\n\r\n        const uploading = this.state.uploading ?\r\n            <div><p> Uploading Image, please wait ... </p></div>\r\n            :\r\n            <span />\r\n        return (\r\n            <div>\r\n                {uploading}\r\n                <video autoPlay playsInline muted id=\"webcam\" width=\"100%\" height=\"200\" />\r\n                <br />\r\n                <div className=\"imageCanvas\">\r\n                    {imageDisplay}\r\n                </div>\r\n                {buttons}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    captureImage = async () => {\r\n        const capturedData = this.webcam.takeBase64Photo({ type: 'jpeg', quality: 0.8 });\r\n        this.setState({\r\n            captured: true,\r\n            capturedImage: capturedData.base64\r\n        });\r\n    }\r\n\r\n    discardImage = () => {\r\n        this.setState({\r\n            captured: false,\r\n            capturedImage: null\r\n        })\r\n    }\r\n\r\n    uploadImage = () => {\r\n        if (this.props.offline) {\r\n            console.log(\"you're using in offline mode sha\");\r\n            // create a random string with a prefix\r\n            const prefix = 'cloudy_pwa_';\r\n            // create random string\r\n            const rs = Math.random().toString(36).substr(2, 5);\r\n            localStorage.setItem(`${prefix}${rs}`, this.state.capturedImage);\r\n            alert('Image saved locally, it will be uploaded to your Cloudinary media library once internet connection is detected');\r\n            this.discardImage();\r\n            // save image to local storage\r\n        } else {\r\n            this.setState({ 'uploading': true });\r\n            axios.post(\r\n                `https://api.cloudinary.com/v1_1/dsrvtc0mt/image/upload`,\r\n                {\r\n                    file: this.state.capturedImage,\r\n                    upload_preset: 'pwa_cloudinary'\r\n                }\r\n            ).then((data) => this.checkUploadStatus(data)).catch((error) => {\r\n                alert('Sorry, we encountered an error uploading your image');\r\n                this.setState({ 'uploading': false });\r\n            });\r\n        }\r\n    }\r\n\r\n    findLocalItems = (query: any) => {\r\n        let i;\r\n        let results = [];\r\n        for (i in localStorage) {\r\n            if (localStorage.hasOwnProperty(i)) {\r\n                if (i.match(query) || (!query && typeof i === 'string')) {\r\n                    const value = localStorage.getItem(i);\r\n                    results.push({ key: i, val: value });\r\n                }\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    checkUploadStatus = (data: any) => {\r\n        this.setState({ 'uploading': false });\r\n        if (data.status === 200) {\r\n            alert('Image Uploaded to Cloudinary Media Library');\r\n            this.discardImage();\r\n        } else {\r\n            alert('Sorry, we encountered an error uploading your image');\r\n        }\r\n    }\r\n\r\n    batchUploads = () => {\r\n        // this is where all the images saved can be uploaded as batch uploads\r\n        const images = this.findLocalItems(/^cloudy_pwa_/);\r\n        let error = false;\r\n        if (images.length > 0) {\r\n            this.setState({ 'uploading': true });\r\n            for (let i = 0; i < images.length; i++) {\r\n                // upload\r\n                axios.post(\r\n                    `https://api.cloudinary.com/v1_1/dsrvtc0mt/image/upload`,\r\n                    {\r\n                        file: images[i].val,\r\n                        upload_preset: 'pwa_cloudinary'\r\n                    }\r\n\r\n                ).then(\r\n                  (data) => this.checkUploadStatus(data)\r\n                ).catch((error) => {\r\n                    error = true;\r\n                })\r\n            }\r\n            this.setState({ 'uploading': false });\r\n            if (!error) {\r\n                alert(\"All saved images have been uploaded to your Cloudinary Media Library\");\r\n            }\r\n        }\r\n    }\r\n}","import * as React from \"react\";\r\nimport { useState, useEffect } from 'react';\r\nimport './App.css';\r\nimport { ITodo } from \"./components/IApp\";\r\nimport { TodoListRenderer } from \"./components/TodoList\";\r\nimport { TodoFormContainer } from \"./components/TodoFormContainer\";\r\nimport { ThemeContext, themes } from \"./components/ThemeContext\";\r\nimport { Toolbar } from \"./components/ToolBar\";\r\nimport { Notifier } from \"./components/Notifier\";\r\nimport { CloudCamera } from \"./components/CloudCamera/index\"\r\n\r\ninterface IHooksAppProps {\r\n  todos: ITodo[];\r\n}\r\n\r\nconst App = (props: IHooksAppProps) => {\r\n  const [todos, setTodos] = useState(props.todos);\r\n  const [theme, setTheme] = useState(themes.light);\r\n  const [offline, setOffline] = useState(false);\r\n  const [toggleThemeCount, setToggleThemeCount] = useState(0);\r\n\r\n  const addTodo = (todoText: string) => {\r\n    const todo: ITodo = { text: todoText };\r\n    const newTodos = [...todos, todo];\r\n    setTodos(newTodos);\r\n  }\r\n\r\n  const completeTodo = (index: number) => {\r\n    const newTodos = [...todos];\r\n    newTodos[index].isCompleted = true;\r\n    setTodos(newTodos);\r\n  }\r\n\r\n  const removeTodo = (index: number) => {\r\n    const newTodos = [...todos];\r\n    newTodos.splice(index, 1);\r\n    setTodos(newTodos);\r\n  }\r\n\r\n  const toggleTheme = () => {\r\n    const newTheme = (theme === themes.dark ? themes.light : themes.dark);\r\n    setTheme(newTheme);\r\n    setToggleThemeCount(toggleThemeCount + 1);\r\n  }\r\n \r\n  useEffect(() => {\r\n    window.addEventListener('online', () => {\r\n      setOffline(false);\r\n    });\r\n\r\n    window.addEventListener('offline', () => {\r\n      setOffline(true);\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    let offlineStatus = !navigator.onLine;\r\n        if (offline !== offlineStatus) {\r\n          setOffline(offlineStatus);\r\n        }\r\n  });\r\n \r\n  useEffect(() => {\r\n  /*\r\n    - By using this Hook, you tell React that your component needs to do something after render\r\n    - by default useEffect run after every render\r\n    - Unlike componentDidMount or componentDidUpdate,\r\n     effects scheduled with useEffect don’t block the browser from updating the screen. This makes your app feel more responsive.\r\n      The majority of effects don’t need to happen synchronously.\r\n       In the uncommon cases where they do (such as measuring the layout), \r\n       there is a separate useLayoutEffect Hook with an API identical to useEffect. \r\n    */\r\n   /*React to skip applying an effect if certain values haven’t changed between re-renders. \r\n     To do so, pass an array as an optional second argument to useEffect: */\r\n    document.title = `You clicked hooks-app themChange button ${toggleThemeCount} times`;\r\n    /*\r\n     If your effect returns a function, React will run it when it is time to clean up:\r\n    */\r\n  }, [toggleThemeCount]);\r\n\r\n  return (\r\n    <div className=\"app\">\r\n      <ThemeContext.Provider value={{ theme: theme, toggleTheme: toggleTheme }}>\r\n        <Toolbar />\r\n      </ThemeContext.Provider>\r\n      <TodoListRenderer todos={todos} onComplete={completeTodo} onRemove={removeTodo} />\r\n      <TodoFormContainer addTodo={addTodo} />\r\n      <Notifier offline={offline} />\r\n      <CloudCamera offline={offline} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker-custom.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './registerServiceWorker';\r\nimport { ITodo } from './components/IApp';\r\n\r\nconst todos: ITodo[] = [\r\n    { text: \"Learn1204 about React\" },\r\n    { text: \"Meet friend for lunch\" },\r\n    { text: \"Build really cool todo app\" }\r\n]\r\n\r\n\r\nReactDOM.render(<App todos={todos}/>, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}