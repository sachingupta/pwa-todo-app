{"version":3,"sources":["components/Todo.tsx","components/TodoList.tsx","components/TodoForm.tsx","components/TodoFormContainer.tsx","components/ThemeContext.ts","components/ThemedButton.tsx","components/ToolBar.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Todo","props","todo","react","className","style","textDecoration","isCompleted","text","onClick","onComplete","index","onRemove","TodoListRenderer","todos","todosRender","length","push","Todo_Todo","key","TodoForm","onSubmit","type","value","onChange","TodoFormContainer","_useState","useState","_useState2","Object","slicedToArray","setValue","e","preventDefault","addTodo","target","themes","light","foreground","background","color","dark","ThemeContext","React","theme","toggleTheme","ThemedButton","_useContext","useContext","backgroundColor","Toolbar","App","setTodos","_useState3","_useState4","setTheme","_useState5","_useState6","toggleThemeCount","setToggleThemeCount","useEffect","document","title","concat","Provider","TodoList_TodoListRenderer","newTodos","toConsumableArray","splice","todoText","Boolean","window","location","hostname","match","ReactDOM","render","react_default","a","createElement","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.51db4499.chunk.js","sourcesContent":["import * as React from \"react\";\r\nimport { ITodo } from \"./IApp\";\r\n\r\ninterface ITodoProps {\r\n    index: number;\r\n    todo: ITodo;\r\n    onComplete: (index: number) => void;\r\n    onRemove: (index: number) => void;\r\n}\r\n\r\nexport const Todo = (props: ITodoProps) => {\r\n    const { todo } = props;\r\n    return  (\r\n        <div\r\n          className=\"todo\"\r\n          style={{ textDecoration: todo.isCompleted ? \"line-through\" : \"\" }}\r\n          >\r\n          {todo.text}\r\n    \r\n          <div>\r\n            <button onClick={() => { props.onComplete(props.index) }}>Complete</button>\r\n            <button onClick={() => { props.onRemove(props.index) }}>x</button>\r\n          </div>\r\n        </div>\r\n      );\r\n}","import * as React from \"react\";\r\nimport { ITodo } from \"./IApp\";\r\n\r\nimport { Todo } from \"./Todo\";\r\n\r\ninterface ITodoListRendererProps {\r\n    todos: ITodo[];\r\n    onComplete: (index: number) => void;\r\n    onRemove: (index: number) => void;\r\n}\r\n\r\nexport const TodoListRenderer = (props: ITodoListRendererProps) => {\r\n    const { todos } = props;\r\n    const todosRender: any[] = [];\r\n    for (let index = 0; index < todos.length; index++) {\r\n        todosRender.push(<Todo\r\n            key={index}\r\n            index={index}\r\n            todo={todos[index]}\r\n            onComplete={props.onComplete}\r\n            onRemove={props.onRemove}\r\n        />);\r\n    }\r\n    return (\r\n        <div className=\"todo-list\">\r\n            {todosRender}\r\n        </div>\r\n    );\r\n}","import * as React from \"react\";\r\n\r\ninterface ITodoFormProps {\r\n  value: string;\r\n  onChange: (e: any) => void;\r\n  onSubmit: (e: any) => void;\r\n}\r\n\r\nexport function TodoForm(props: ITodoFormProps){\r\n    return (\r\n        <form onSubmit={props.onSubmit}>\r\n          <input className=\"todoInput\"\r\n            type=\"text\"\r\n            value={props.value}\r\n            onChange={props.onChange}\r\n          />\r\n        </form>\r\n      );\r\n}","import * as React from \"react\";\r\nimport { useState } from \"react\";\r\n\r\nimport { TodoForm } from \"../components/TodoForm\";\r\n\r\ninterface ITodoFormContainerProps {\r\n    addTodo: (text: string) => void;\r\n}\r\n\r\nexport function TodoFormContainer(props: ITodoFormContainerProps) {\r\n    const [value, setValue] = useState(\"\");\r\n\r\n    const onChange = (e: any) => {\r\n        setValue(e.target.value);\r\n    };\r\n\r\n    const handleSubmit = (e: Event) => {\r\n        e.preventDefault();\r\n        if (value) {\r\n            props.addTodo(value);\r\n            setValue(\"\");\r\n        }\r\n    }\r\n    return (\r\n        <TodoForm value={value} onSubmit={handleSubmit} onChange={onChange} />\r\n    );\r\n}","import * as React from \"react\";\r\n\r\nexport const themes = {\r\n    light: {\r\n      foreground: '#000000',\r\n      background: '#eeeeee',\r\n      color: '#000000',\r\n    },\r\n    dark: {\r\n      foreground: '#ffffff',\r\n      background: '#222222',\r\n      color: '#ffffff',\r\n    },\r\n  };\r\n\r\n  export const ThemeContext = React.createContext(\r\n    {\r\n        theme: themes.dark,\r\n        toggleTheme: () => {},\r\n      }\r\n  );","import * as React from \"react\";\r\nimport { useContext } from \"react\";\r\nimport { ThemeContext } from \"../components/ThemeContext\";\r\n\r\nexport function ThemedButton() {\r\n    const { theme, toggleTheme } = useContext(ThemeContext);\r\n    return (\r\n        <button\r\n            onClick={toggleTheme}\r\n            style={{ backgroundColor: theme.background, color: theme.color }}>\r\n            Toggle Theme\r\n        </button>\r\n    );\r\n}","import * as React from \"react\";\r\nimport { ThemedButton } from \"./ThemedButton\";\r\n\r\n// An intermediate component that uses the ThemedButton\r\nexport function Toolbar() {\r\n    return (\r\n      <ThemedButton />\r\n    );\r\n  }","import * as React from \"react\";\nimport { useState, useEffect } from 'react';\nimport './App.css';\nimport { ITodo } from \"./components/IApp\";\nimport { TodoListRenderer } from \"./components/TodoList\";\nimport { TodoFormContainer } from \"./components/TodoFormContainer\";\nimport { ThemeContext, themes } from \"./components/ThemeContext\";\nimport { Toolbar } from \"./components/ToolBar\";\n\ninterface IHooksAppProps {\n  todos: ITodo[];\n}\n\nconst App = (props: IHooksAppProps) => {\n  const [todos, setTodos] = useState(props.todos);\n  const [theme, setTheme] = useState(themes.light);\n  const [toggleThemeCount, setToggleThemeCount] = useState(0);\n\n  const addTodo = (todoText: string) => {\n    const todo: ITodo = { text: todoText };\n    const newTodos = [...todos, todo];\n    setTodos(newTodos);\n  }\n\n  const completeTodo = (index: number) => {\n    const newTodos = [...todos];\n    newTodos[index].isCompleted = true;\n    setTodos(newTodos);\n  }\n\n  const removeTodo = (index: number) => {\n    const newTodos = [...todos];\n    newTodos.splice(index, 1);\n    setTodos(newTodos);\n  }\n\n  const toggleTheme = () => {\n    const newTheme = (theme === themes.dark ? themes.light : themes.dark);\n    setTheme(newTheme);\n    setToggleThemeCount(toggleThemeCount + 1);\n  }\n\n  useEffect(() => {\n  /*\n    - By using this Hook, you tell React that your component needs to do something after render\n    - by default useEffect run after every render\n    - Unlike componentDidMount or componentDidUpdate,\n     effects scheduled with useEffect don’t block the browser from updating the screen. This makes your app feel more responsive.\n      The majority of effects don’t need to happen synchronously.\n       In the uncommon cases where they do (such as measuring the layout), \n       there is a separate useLayoutEffect Hook with an API identical to useEffect. \n    */\n   /*React to skip applying an effect if certain values haven’t changed between re-renders. \n     To do so, pass an array as an optional second argument to useEffect: */\n    document.title = `You clicked hooks-app themChange button ${toggleThemeCount} times`;\n    /*\n     If your effect returns a function, React will run it when it is time to clean up:\n    */\n  }, [toggleThemeCount]);\n\n  return (\n    <div className=\"App\">\n      <ThemeContext.Provider value={{ theme: theme, toggleTheme: toggleTheme }}>\n        <Toolbar />\n      </ThemeContext.Provider>\n      <TodoListRenderer todos={todos} onComplete={completeTodo} onRemove={removeTodo} />\n      <TodoFormContainer addTodo={addTodo} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { ITodo } from './components/IApp';\n\nconst todos: ITodo[] = [\n    { text: \"Learn1204 about React\" },\n    { text: \"Meet friend for lunch\" },\n    { text: \"Build really cool todo app\" }\n]\n\n\nReactDOM.render(<App todos={todos}/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}